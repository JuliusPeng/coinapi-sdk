{-
   OEML - REST API

   This section will provide necessary information about the `CoinAPI OEML REST API` protocol. 

   OpenAPI Version: 3.0.0
   OEML - REST API API version: v1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OEML-REST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OEML-REST.Model where

import OEML-REST.Core
import OEML-REST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** ClientOrderId
newtype ClientOrderId = ClientOrderId { unClientOrderId :: Text } deriving (P.Eq, P.Show)

-- ** ExchangeId
newtype ExchangeId = ExchangeId { unExchangeId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Balance
-- | Balance
data Balance = Balance
  { balanceType :: !(Maybe Text) -- ^ "type" - Result type.
  , balanceExchangeName :: !(Maybe Text) -- ^ "exchange_name" - Exchange name.
  , balanceData :: !(Maybe [BalanceData]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Balance
instance A.FromJSON Balance where
  parseJSON = A.withObject "Balance" $ \o ->
    Balance
      <$> (o .:? "type")
      <*> (o .:? "exchange_name")
      <*> (o .:? "data")

-- | ToJSON Balance
instance A.ToJSON Balance where
  toJSON Balance {..} =
   _omitNulls
      [ "type" .= balanceType
      , "exchange_name" .= balanceExchangeName
      , "data" .= balanceData
      ]


-- | Construct a value of type 'Balance' (by applying it's required fields, if any)
mkBalance
  :: Balance
mkBalance =
  Balance
  { balanceType = Nothing
  , balanceExchangeName = Nothing
  , balanceData = Nothing
  }

-- ** BalanceData
-- | BalanceData
data BalanceData = BalanceData
  { balanceDataId :: !(Maybe Text) -- ^ "id" - Exchange identifier.
  , balanceDataSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - Exchange currency code.
  , balanceDataSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - CoinAPI currency code.
  , balanceDataBalance :: !(Maybe Float) -- ^ "balance" - Value of the current total currency balance on the exchange.
  , balanceDataAvailable :: !(Maybe Float) -- ^ "available" - Value of the current available currency balance on the exchange that can be used as collateral.
  , balanceDataLocked :: !(Maybe Float) -- ^ "locked" - Value of the current locked currency balance by the exchange.
  , balanceDataUpdateOrigin :: !(Maybe E'UpdateOrigin) -- ^ "update_origin" - Source of the last modification. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BalanceData
instance A.FromJSON BalanceData where
  parseJSON = A.withObject "BalanceData" $ \o ->
    BalanceData
      <$> (o .:? "id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:? "balance")
      <*> (o .:? "available")
      <*> (o .:? "locked")
      <*> (o .:? "update_origin")

-- | ToJSON BalanceData
instance A.ToJSON BalanceData where
  toJSON BalanceData {..} =
   _omitNulls
      [ "id" .= balanceDataId
      , "symbol_exchange" .= balanceDataSymbolExchange
      , "symbol_coinapi" .= balanceDataSymbolCoinapi
      , "balance" .= balanceDataBalance
      , "available" .= balanceDataAvailable
      , "locked" .= balanceDataLocked
      , "update_origin" .= balanceDataUpdateOrigin
      ]


-- | Construct a value of type 'BalanceData' (by applying it's required fields, if any)
mkBalanceData
  :: BalanceData
mkBalanceData =
  BalanceData
  { balanceDataId = Nothing
  , balanceDataSymbolExchange = Nothing
  , balanceDataSymbolCoinapi = Nothing
  , balanceDataBalance = Nothing
  , balanceDataAvailable = Nothing
  , balanceDataLocked = Nothing
  , balanceDataUpdateOrigin = Nothing
  }

-- ** CancelOrderAllRequest
-- | CancelOrderAllRequest
data CancelOrderAllRequest = CancelOrderAllRequest
  { cancelOrderAllRequestExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier from which active orders should be canceled.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CancelOrderAllRequest
instance A.FromJSON CancelOrderAllRequest where
  parseJSON = A.withObject "CancelOrderAllRequest" $ \o ->
    CancelOrderAllRequest
      <$> (o .:  "exchange_id")

-- | ToJSON CancelOrderAllRequest
instance A.ToJSON CancelOrderAllRequest where
  toJSON CancelOrderAllRequest {..} =
   _omitNulls
      [ "exchange_id" .= cancelOrderAllRequestExchangeId
      ]


-- | Construct a value of type 'CancelOrderAllRequest' (by applying it's required fields, if any)
mkCancelOrderAllRequest
  :: Text -- ^ 'cancelOrderAllRequestExchangeId': Exchange identifier from which active orders should be canceled.
  -> CancelOrderAllRequest
mkCancelOrderAllRequest cancelOrderAllRequestExchangeId =
  CancelOrderAllRequest
  { cancelOrderAllRequestExchangeId
  }

-- ** CancelOrderSingleRequest
-- | CancelOrderSingleRequest
data CancelOrderSingleRequest = CancelOrderSingleRequest
  { cancelOrderSingleRequestExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier.
  , cancelOrderSingleRequestExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - The unique identifier of the order assigned by the exchange.
  , cancelOrderSingleRequestClientOrderId :: !(Maybe Text) -- ^ "client_order_id" - The unique identifier of the order assigned by the client.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CancelOrderSingleRequest
instance A.FromJSON CancelOrderSingleRequest where
  parseJSON = A.withObject "CancelOrderSingleRequest" $ \o ->
    CancelOrderSingleRequest
      <$> (o .:? "exchange_id")
      <*> (o .:? "exchange_order_id")
      <*> (o .:? "client_order_id")

-- | ToJSON CancelOrderSingleRequest
instance A.ToJSON CancelOrderSingleRequest where
  toJSON CancelOrderSingleRequest {..} =
   _omitNulls
      [ "exchange_id" .= cancelOrderSingleRequestExchangeId
      , "exchange_order_id" .= cancelOrderSingleRequestExchangeOrderId
      , "client_order_id" .= cancelOrderSingleRequestClientOrderId
      ]


-- | Construct a value of type 'CancelOrderSingleRequest' (by applying it's required fields, if any)
mkCancelOrderSingleRequest
  :: CancelOrderSingleRequest
mkCancelOrderSingleRequest =
  CancelOrderSingleRequest
  { cancelOrderSingleRequestExchangeId = Nothing
  , cancelOrderSingleRequestExchangeOrderId = Nothing
  , cancelOrderSingleRequestClientOrderId = Nothing
  }

-- ** Message
-- | Message
-- Message object.
-- 
data Message = Message
  { messageType :: !(Maybe Text) -- ^ "type" - Type of message.
  , messageSeverity :: !(Maybe Severity) -- ^ "severity"
  , messageExchangeId :: !(Maybe Text) -- ^ "exchange_id" - If message related exchange then identifier of this exchange.
  , messageMessage :: !(Maybe Text) -- ^ "message" - Message text.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Message
instance A.FromJSON Message where
  parseJSON = A.withObject "Message" $ \o ->
    Message
      <$> (o .:? "type")
      <*> (o .:? "severity")
      <*> (o .:? "exchange_id")
      <*> (o .:? "message")

-- | ToJSON Message
instance A.ToJSON Message where
  toJSON Message {..} =
   _omitNulls
      [ "type" .= messageType
      , "severity" .= messageSeverity
      , "exchange_id" .= messageExchangeId
      , "message" .= messageMessage
      ]


-- | Construct a value of type 'Message' (by applying it's required fields, if any)
mkMessage
  :: Message
mkMessage =
  Message
  { messageType = Nothing
  , messageSeverity = Nothing
  , messageExchangeId = Nothing
  , messageMessage = Nothing
  }

-- ** NewOrderSingle
-- | NewOrderSingle
-- The new order message.
data NewOrderSingle = NewOrderSingle
  { newOrderSingleExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier.
  , newOrderSingleClientOrderId :: !(Text) -- ^ /Required/ "client_order_id" - The unique identifier of the order assigned by the client.
  , newOrderSingleSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - Exchange symbol. One of the properties (&#x60;symbol_exchange&#x60;, &#x60;symbol_coinapi&#x60;) are required to identify the market for the new order.
  , newOrderSingleSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - CoinAPI symbol. One of the properties (&#x60;symbol_exchange&#x60;, &#x60;symbol_coinapi&#x60;) are required to identify the market for the new order.
  , newOrderSingleAmountOrder :: !(Double) -- ^ /Required/ "amount_order" - Order quantity.
  , newOrderSinglePrice :: !(Double) -- ^ /Required/ "price" - Order price.
  , newOrderSingleSide :: !(OrdSide) -- ^ /Required/ "side"
  , newOrderSingleOrderType :: !(OrdType) -- ^ /Required/ "order_type"
  , newOrderSingleTimeInForce :: !(TimeInForce) -- ^ /Required/ "time_in_force"
  , newOrderSingleExpireTime :: !(Maybe Date) -- ^ "expire_time" - Expiration time. Conditionaly required for orders with time_in_force &#x3D; &#x60;GOOD_TILL_TIME_EXCHANGE&#x60; or &#x60;GOOD_TILL_TIME_OEML&#x60;.
  , newOrderSingleExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - Order execution instructions are documented in the separate section: &lt;a href&#x3D;\&quot;#oeml-order-params-exec\&quot;&gt;OEML / Starter Guide / Order parameters / Execution instructions&lt;/a&gt; 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NewOrderSingle
instance A.FromJSON NewOrderSingle where
  parseJSON = A.withObject "NewOrderSingle" $ \o ->
    NewOrderSingle
      <$> (o .:  "exchange_id")
      <*> (o .:  "client_order_id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:  "amount_order")
      <*> (o .:  "price")
      <*> (o .:  "side")
      <*> (o .:  "order_type")
      <*> (o .:  "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")

-- | ToJSON NewOrderSingle
instance A.ToJSON NewOrderSingle where
  toJSON NewOrderSingle {..} =
   _omitNulls
      [ "exchange_id" .= newOrderSingleExchangeId
      , "client_order_id" .= newOrderSingleClientOrderId
      , "symbol_exchange" .= newOrderSingleSymbolExchange
      , "symbol_coinapi" .= newOrderSingleSymbolCoinapi
      , "amount_order" .= newOrderSingleAmountOrder
      , "price" .= newOrderSinglePrice
      , "side" .= newOrderSingleSide
      , "order_type" .= newOrderSingleOrderType
      , "time_in_force" .= newOrderSingleTimeInForce
      , "expire_time" .= newOrderSingleExpireTime
      , "exec_inst" .= newOrderSingleExecInst
      ]


-- | Construct a value of type 'NewOrderSingle' (by applying it's required fields, if any)
mkNewOrderSingle
  :: Text -- ^ 'newOrderSingleExchangeId': Exchange identifier.
  -> Text -- ^ 'newOrderSingleClientOrderId': The unique identifier of the order assigned by the client.
  -> Double -- ^ 'newOrderSingleAmountOrder': Order quantity.
  -> Double -- ^ 'newOrderSinglePrice': Order price.
  -> OrdSide -- ^ 'newOrderSingleSide' 
  -> OrdType -- ^ 'newOrderSingleOrderType' 
  -> TimeInForce -- ^ 'newOrderSingleTimeInForce' 
  -> NewOrderSingle
mkNewOrderSingle newOrderSingleExchangeId newOrderSingleClientOrderId newOrderSingleAmountOrder newOrderSinglePrice newOrderSingleSide newOrderSingleOrderType newOrderSingleTimeInForce =
  NewOrderSingle
  { newOrderSingleExchangeId
  , newOrderSingleClientOrderId
  , newOrderSingleSymbolExchange = Nothing
  , newOrderSingleSymbolCoinapi = Nothing
  , newOrderSingleAmountOrder
  , newOrderSinglePrice
  , newOrderSingleSide
  , newOrderSingleOrderType
  , newOrderSingleTimeInForce
  , newOrderSingleExpireTime = Nothing
  , newOrderSingleExecInst = Nothing
  }

-- ** OrderExecutionReport
-- | OrderExecutionReport
data OrderExecutionReport = OrderExecutionReport
  { orderExecutionReportExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier.
  , orderExecutionReportClientOrderId :: !(Text) -- ^ /Required/ "client_order_id" - The unique identifier of the order assigned by the client.
  , orderExecutionReportSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - Exchange symbol. One of the properties (&#x60;symbol_exchange&#x60;, &#x60;symbol_coinapi&#x60;) are required to identify the market for the new order.
  , orderExecutionReportSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - CoinAPI symbol. One of the properties (&#x60;symbol_exchange&#x60;, &#x60;symbol_coinapi&#x60;) are required to identify the market for the new order.
  , orderExecutionReportAmountOrder :: !(Double) -- ^ /Required/ "amount_order" - Order quantity.
  , orderExecutionReportPrice :: !(Double) -- ^ /Required/ "price" - Order price.
  , orderExecutionReportSide :: !(OrdSide) -- ^ /Required/ "side"
  , orderExecutionReportOrderType :: !(OrdType) -- ^ /Required/ "order_type"
  , orderExecutionReportTimeInForce :: !(TimeInForce) -- ^ /Required/ "time_in_force"
  , orderExecutionReportExpireTime :: !(Maybe Date) -- ^ "expire_time" - Expiration time. Conditionaly required for orders with time_in_force &#x3D; &#x60;GOOD_TILL_TIME_EXCHANGE&#x60; or &#x60;GOOD_TILL_TIME_OEML&#x60;.
  , orderExecutionReportExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - Order execution instructions are documented in the separate section: &lt;a href&#x3D;\&quot;#oeml-order-params-exec\&quot;&gt;OEML / Starter Guide / Order parameters / Execution instructions&lt;/a&gt; 
  , orderExecutionReportClientOrderIdFormatExchange :: !(Text) -- ^ /Required/ "client_order_id_format_exchange" - The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  , orderExecutionReportExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - The unique identifier of the order assigned by the exchange.
  , orderExecutionReportAmountOpen :: !(Double) -- ^ /Required/ "amount_open" - Amount open
  , orderExecutionReportAmountFilled :: !(Double) -- ^ /Required/ "amount_filled" - Amount filled
  , orderExecutionReportStatus :: !(OrdStatus) -- ^ /Required/ "status"
  , orderExecutionReportTimeOrder :: !([[Text]]) -- ^ /Required/ "time_order" - Timestamped history of order status changes.
  , orderExecutionReportErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderExecutionReport
instance A.FromJSON OrderExecutionReport where
  parseJSON = A.withObject "OrderExecutionReport" $ \o ->
    OrderExecutionReport
      <$> (o .:  "exchange_id")
      <*> (o .:  "client_order_id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:  "amount_order")
      <*> (o .:  "price")
      <*> (o .:  "side")
      <*> (o .:  "order_type")
      <*> (o .:  "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")
      <*> (o .:  "client_order_id_format_exchange")
      <*> (o .:? "exchange_order_id")
      <*> (o .:  "amount_open")
      <*> (o .:  "amount_filled")
      <*> (o .:  "status")
      <*> (o .:  "time_order")
      <*> (o .:? "error_message")

-- | ToJSON OrderExecutionReport
instance A.ToJSON OrderExecutionReport where
  toJSON OrderExecutionReport {..} =
   _omitNulls
      [ "exchange_id" .= orderExecutionReportExchangeId
      , "client_order_id" .= orderExecutionReportClientOrderId
      , "symbol_exchange" .= orderExecutionReportSymbolExchange
      , "symbol_coinapi" .= orderExecutionReportSymbolCoinapi
      , "amount_order" .= orderExecutionReportAmountOrder
      , "price" .= orderExecutionReportPrice
      , "side" .= orderExecutionReportSide
      , "order_type" .= orderExecutionReportOrderType
      , "time_in_force" .= orderExecutionReportTimeInForce
      , "expire_time" .= orderExecutionReportExpireTime
      , "exec_inst" .= orderExecutionReportExecInst
      , "client_order_id_format_exchange" .= orderExecutionReportClientOrderIdFormatExchange
      , "exchange_order_id" .= orderExecutionReportExchangeOrderId
      , "amount_open" .= orderExecutionReportAmountOpen
      , "amount_filled" .= orderExecutionReportAmountFilled
      , "status" .= orderExecutionReportStatus
      , "time_order" .= orderExecutionReportTimeOrder
      , "error_message" .= orderExecutionReportErrorMessage
      ]


-- | Construct a value of type 'OrderExecutionReport' (by applying it's required fields, if any)
mkOrderExecutionReport
  :: Text -- ^ 'orderExecutionReportExchangeId': Exchange identifier.
  -> Text -- ^ 'orderExecutionReportClientOrderId': The unique identifier of the order assigned by the client.
  -> Double -- ^ 'orderExecutionReportAmountOrder': Order quantity.
  -> Double -- ^ 'orderExecutionReportPrice': Order price.
  -> OrdSide -- ^ 'orderExecutionReportSide' 
  -> OrdType -- ^ 'orderExecutionReportOrderType' 
  -> TimeInForce -- ^ 'orderExecutionReportTimeInForce' 
  -> Text -- ^ 'orderExecutionReportClientOrderIdFormatExchange': The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  -> Double -- ^ 'orderExecutionReportAmountOpen': Amount open
  -> Double -- ^ 'orderExecutionReportAmountFilled': Amount filled
  -> OrdStatus -- ^ 'orderExecutionReportStatus' 
  -> [[Text]] -- ^ 'orderExecutionReportTimeOrder': Timestamped history of order status changes.
  -> OrderExecutionReport
mkOrderExecutionReport orderExecutionReportExchangeId orderExecutionReportClientOrderId orderExecutionReportAmountOrder orderExecutionReportPrice orderExecutionReportSide orderExecutionReportOrderType orderExecutionReportTimeInForce orderExecutionReportClientOrderIdFormatExchange orderExecutionReportAmountOpen orderExecutionReportAmountFilled orderExecutionReportStatus orderExecutionReportTimeOrder =
  OrderExecutionReport
  { orderExecutionReportExchangeId
  , orderExecutionReportClientOrderId
  , orderExecutionReportSymbolExchange = Nothing
  , orderExecutionReportSymbolCoinapi = Nothing
  , orderExecutionReportAmountOrder
  , orderExecutionReportPrice
  , orderExecutionReportSide
  , orderExecutionReportOrderType
  , orderExecutionReportTimeInForce
  , orderExecutionReportExpireTime = Nothing
  , orderExecutionReportExecInst = Nothing
  , orderExecutionReportClientOrderIdFormatExchange
  , orderExecutionReportExchangeOrderId = Nothing
  , orderExecutionReportAmountOpen
  , orderExecutionReportAmountFilled
  , orderExecutionReportStatus
  , orderExecutionReportTimeOrder
  , orderExecutionReportErrorMessage = Nothing
  }

-- ** OrderExecutionReportAllOf
-- | OrderExecutionReportAllOf
-- The order execution report message.
data OrderExecutionReportAllOf = OrderExecutionReportAllOf
  { orderExecutionReportAllOfClientOrderIdFormatExchange :: !(Text) -- ^ /Required/ "client_order_id_format_exchange" - The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  , orderExecutionReportAllOfExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - The unique identifier of the order assigned by the exchange.
  , orderExecutionReportAllOfAmountOpen :: !(Double) -- ^ /Required/ "amount_open" - Amount open
  , orderExecutionReportAllOfAmountFilled :: !(Double) -- ^ /Required/ "amount_filled" - Amount filled
  , orderExecutionReportAllOfStatus :: !(OrdStatus) -- ^ /Required/ "status"
  , orderExecutionReportAllOfTimeOrder :: !([[Text]]) -- ^ /Required/ "time_order" - Timestamped history of order status changes.
  , orderExecutionReportAllOfErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderExecutionReportAllOf
instance A.FromJSON OrderExecutionReportAllOf where
  parseJSON = A.withObject "OrderExecutionReportAllOf" $ \o ->
    OrderExecutionReportAllOf
      <$> (o .:  "client_order_id_format_exchange")
      <*> (o .:? "exchange_order_id")
      <*> (o .:  "amount_open")
      <*> (o .:  "amount_filled")
      <*> (o .:  "status")
      <*> (o .:  "time_order")
      <*> (o .:? "error_message")

-- | ToJSON OrderExecutionReportAllOf
instance A.ToJSON OrderExecutionReportAllOf where
  toJSON OrderExecutionReportAllOf {..} =
   _omitNulls
      [ "client_order_id_format_exchange" .= orderExecutionReportAllOfClientOrderIdFormatExchange
      , "exchange_order_id" .= orderExecutionReportAllOfExchangeOrderId
      , "amount_open" .= orderExecutionReportAllOfAmountOpen
      , "amount_filled" .= orderExecutionReportAllOfAmountFilled
      , "status" .= orderExecutionReportAllOfStatus
      , "time_order" .= orderExecutionReportAllOfTimeOrder
      , "error_message" .= orderExecutionReportAllOfErrorMessage
      ]


-- | Construct a value of type 'OrderExecutionReportAllOf' (by applying it's required fields, if any)
mkOrderExecutionReportAllOf
  :: Text -- ^ 'orderExecutionReportAllOfClientOrderIdFormatExchange': The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  -> Double -- ^ 'orderExecutionReportAllOfAmountOpen': Amount open
  -> Double -- ^ 'orderExecutionReportAllOfAmountFilled': Amount filled
  -> OrdStatus -- ^ 'orderExecutionReportAllOfStatus' 
  -> [[Text]] -- ^ 'orderExecutionReportAllOfTimeOrder': Timestamped history of order status changes.
  -> OrderExecutionReportAllOf
mkOrderExecutionReportAllOf orderExecutionReportAllOfClientOrderIdFormatExchange orderExecutionReportAllOfAmountOpen orderExecutionReportAllOfAmountFilled orderExecutionReportAllOfStatus orderExecutionReportAllOfTimeOrder =
  OrderExecutionReportAllOf
  { orderExecutionReportAllOfClientOrderIdFormatExchange
  , orderExecutionReportAllOfExchangeOrderId = Nothing
  , orderExecutionReportAllOfAmountOpen
  , orderExecutionReportAllOfAmountFilled
  , orderExecutionReportAllOfStatus
  , orderExecutionReportAllOfTimeOrder
  , orderExecutionReportAllOfErrorMessage = Nothing
  }

-- ** Position
-- | Position
data Position = Position
  { positionType :: !(Maybe Text) -- ^ "type" - Result type.
  , positionExchangeName :: !(Maybe Text) -- ^ "exchange_name" - Name of exchange.
  , positionData :: !(Maybe [PositionData]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Position
instance A.FromJSON Position where
  parseJSON = A.withObject "Position" $ \o ->
    Position
      <$> (o .:? "type")
      <*> (o .:? "exchange_name")
      <*> (o .:? "data")

-- | ToJSON Position
instance A.ToJSON Position where
  toJSON Position {..} =
   _omitNulls
      [ "type" .= positionType
      , "exchange_name" .= positionExchangeName
      , "data" .= positionData
      ]


-- | Construct a value of type 'Position' (by applying it's required fields, if any)
mkPosition
  :: Position
mkPosition =
  Position
  { positionType = Nothing
  , positionExchangeName = Nothing
  , positionData = Nothing
  }

-- ** PositionData
-- | PositionData
data PositionData = PositionData
  { positionDataId :: !(Maybe Text) -- ^ "id" - Unique position ID
  , positionDataSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - The contract for this position.
  , positionDataSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - The coinapi contract for this position.
  , positionDataAvgEntryPrice :: !(Maybe Double) -- ^ "avg_entry_price"
  , positionDataQuantity :: !(Maybe Double) -- ^ "quantity" - The current position amount in contracts.
  , positionDataIsBuy :: !(Maybe Bool) -- ^ "is_buy"
  , positionDataUnrealisedPnL :: !(Maybe Double) -- ^ "unrealised_pn_l" - Unrealised PNL is all the unrealised profit or loss coming from your portfolio&#39;s open positions.
  , positionDataLeverage :: !(Maybe Double) -- ^ "leverage" - 1 / initMarginReq.
  , positionDataCrossMargin :: !(Maybe Bool) -- ^ "cross_margin" - True/false depending on whether you set cross margin on this position.
  , positionDataLiquidationPrice :: !(Maybe Double) -- ^ "liquidation_price" - Once markPrice reaches this price, this position will be liquidated.
  , positionDataRawData :: !(Maybe Text) -- ^ "raw_data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PositionData
instance A.FromJSON PositionData where
  parseJSON = A.withObject "PositionData" $ \o ->
    PositionData
      <$> (o .:? "id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:? "avg_entry_price")
      <*> (o .:? "quantity")
      <*> (o .:? "is_buy")
      <*> (o .:? "unrealised_pn_l")
      <*> (o .:? "leverage")
      <*> (o .:? "cross_margin")
      <*> (o .:? "liquidation_price")
      <*> (o .:? "raw_data")

-- | ToJSON PositionData
instance A.ToJSON PositionData where
  toJSON PositionData {..} =
   _omitNulls
      [ "id" .= positionDataId
      , "symbol_exchange" .= positionDataSymbolExchange
      , "symbol_coinapi" .= positionDataSymbolCoinapi
      , "avg_entry_price" .= positionDataAvgEntryPrice
      , "quantity" .= positionDataQuantity
      , "is_buy" .= positionDataIsBuy
      , "unrealised_pn_l" .= positionDataUnrealisedPnL
      , "leverage" .= positionDataLeverage
      , "cross_margin" .= positionDataCrossMargin
      , "liquidation_price" .= positionDataLiquidationPrice
      , "raw_data" .= positionDataRawData
      ]


-- | Construct a value of type 'PositionData' (by applying it's required fields, if any)
mkPositionData
  :: PositionData
mkPositionData =
  PositionData
  { positionDataId = Nothing
  , positionDataSymbolExchange = Nothing
  , positionDataSymbolCoinapi = Nothing
  , positionDataAvgEntryPrice = Nothing
  , positionDataQuantity = Nothing
  , positionDataIsBuy = Nothing
  , positionDataUnrealisedPnL = Nothing
  , positionDataLeverage = Nothing
  , positionDataCrossMargin = Nothing
  , positionDataLiquidationPrice = Nothing
  , positionDataRawData = Nothing
  }

-- ** ValidationError
-- | ValidationError
-- JSON validation error.
-- 
data ValidationError = ValidationError
  { validationErrorType :: !(Maybe Text) -- ^ "type"
  , validationErrorTitle :: !(Maybe Text) -- ^ "title"
  , validationErrorStatus :: !(Maybe Double) -- ^ "status"
  , validationErrorTraceId :: !(Maybe Text) -- ^ "traceId"
  , validationErrorErrors :: !(Maybe Text) -- ^ "errors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ValidationError
instance A.FromJSON ValidationError where
  parseJSON = A.withObject "ValidationError" $ \o ->
    ValidationError
      <$> (o .:? "type")
      <*> (o .:? "title")
      <*> (o .:? "status")
      <*> (o .:? "traceId")
      <*> (o .:? "errors")

-- | ToJSON ValidationError
instance A.ToJSON ValidationError where
  toJSON ValidationError {..} =
   _omitNulls
      [ "type" .= validationErrorType
      , "title" .= validationErrorTitle
      , "status" .= validationErrorStatus
      , "traceId" .= validationErrorTraceId
      , "errors" .= validationErrorErrors
      ]


-- | Construct a value of type 'ValidationError' (by applying it's required fields, if any)
mkValidationError
  :: ValidationError
mkValidationError =
  ValidationError
  { validationErrorType = Nothing
  , validationErrorTitle = Nothing
  , validationErrorStatus = Nothing
  , validationErrorTraceId = Nothing
  , validationErrorErrors = Nothing
  }


-- * Enums


-- ** E'ExecInst

-- | Enum of 'Text'
data E'ExecInst
  = E'ExecInst'MAKER_OR_CANCEL -- ^ @"MAKER_OR_CANCEL"@
  | E'ExecInst'AUCTION_ONLY -- ^ @"AUCTION_ONLY"@
  | E'ExecInst'INDICATION_OF_INTEREST -- ^ @"INDICATION_OF_INTEREST"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ExecInst where toJSON = A.toJSON . fromE'ExecInst
instance A.FromJSON E'ExecInst where parseJSON o = P.either P.fail (pure . P.id) . toE'ExecInst =<< A.parseJSON o
instance WH.ToHttpApiData E'ExecInst where toQueryParam = WH.toQueryParam . fromE'ExecInst
instance WH.FromHttpApiData E'ExecInst where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ExecInst
instance MimeRender MimeMultipartFormData E'ExecInst where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ExecInst' enum
fromE'ExecInst :: E'ExecInst -> Text
fromE'ExecInst = \case
  E'ExecInst'MAKER_OR_CANCEL -> "MAKER_OR_CANCEL"
  E'ExecInst'AUCTION_ONLY -> "AUCTION_ONLY"
  E'ExecInst'INDICATION_OF_INTEREST -> "INDICATION_OF_INTEREST"

-- | parse 'E'ExecInst' enum
toE'ExecInst :: Text -> P.Either String E'ExecInst
toE'ExecInst = \case
  "MAKER_OR_CANCEL" -> P.Right E'ExecInst'MAKER_OR_CANCEL
  "AUCTION_ONLY" -> P.Right E'ExecInst'AUCTION_ONLY
  "INDICATION_OF_INTEREST" -> P.Right E'ExecInst'INDICATION_OF_INTEREST
  s -> P.Left $ "toE'ExecInst: enum parse failure: " P.++ P.show s


-- ** E'UpdateOrigin

-- | Enum of 'Text' . 
-- Source of the last modification. 
data E'UpdateOrigin
  = E'UpdateOrigin'INITIALIZATION -- ^ @"INITIALIZATION"@
  | E'UpdateOrigin'BALANCE_MANAGER -- ^ @"BALANCE_MANAGER"@
  | E'UpdateOrigin'EXCHANGE -- ^ @"EXCHANGE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'UpdateOrigin where toJSON = A.toJSON . fromE'UpdateOrigin
instance A.FromJSON E'UpdateOrigin where parseJSON o = P.either P.fail (pure . P.id) . toE'UpdateOrigin =<< A.parseJSON o
instance WH.ToHttpApiData E'UpdateOrigin where toQueryParam = WH.toQueryParam . fromE'UpdateOrigin
instance WH.FromHttpApiData E'UpdateOrigin where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'UpdateOrigin
instance MimeRender MimeMultipartFormData E'UpdateOrigin where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'UpdateOrigin' enum
fromE'UpdateOrigin :: E'UpdateOrigin -> Text
fromE'UpdateOrigin = \case
  E'UpdateOrigin'INITIALIZATION -> "INITIALIZATION"
  E'UpdateOrigin'BALANCE_MANAGER -> "BALANCE_MANAGER"
  E'UpdateOrigin'EXCHANGE -> "EXCHANGE"

-- | parse 'E'UpdateOrigin' enum
toE'UpdateOrigin :: Text -> P.Either String E'UpdateOrigin
toE'UpdateOrigin = \case
  "INITIALIZATION" -> P.Right E'UpdateOrigin'INITIALIZATION
  "BALANCE_MANAGER" -> P.Right E'UpdateOrigin'BALANCE_MANAGER
  "EXCHANGE" -> P.Right E'UpdateOrigin'EXCHANGE
  s -> P.Left $ "toE'UpdateOrigin: enum parse failure: " P.++ P.show s


-- ** OrdSide

-- | Enum of 'Text' . 
-- Side of order. 
data OrdSide
  = OrdSide'BUY -- ^ @"BUY"@
  | OrdSide'SELL -- ^ @"SELL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdSide where toJSON = A.toJSON . fromOrdSide
instance A.FromJSON OrdSide where parseJSON o = P.either P.fail (pure . P.id) . toOrdSide =<< A.parseJSON o
instance WH.ToHttpApiData OrdSide where toQueryParam = WH.toQueryParam . fromOrdSide
instance WH.FromHttpApiData OrdSide where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdSide
instance MimeRender MimeMultipartFormData OrdSide where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdSide' enum
fromOrdSide :: OrdSide -> Text
fromOrdSide = \case
  OrdSide'BUY -> "BUY"
  OrdSide'SELL -> "SELL"

-- | parse 'OrdSide' enum
toOrdSide :: Text -> P.Either String OrdSide
toOrdSide = \case
  "BUY" -> P.Right OrdSide'BUY
  "SELL" -> P.Right OrdSide'SELL
  s -> P.Left $ "toOrdSide: enum parse failure: " P.++ P.show s


-- ** OrdStatus

-- | Enum of 'Text' . 
-- Order statuses and the lifecycle are documented in the separate section: <a href=\"#oeml-order-lifecycle\">OEML / Starter Guide / Order Lifecycle</a> 
data OrdStatus
  = OrdStatus'RECEIVED -- ^ @"RECEIVED"@
  | OrdStatus'ROUTING -- ^ @"ROUTING"@
  | OrdStatus'ROUTED -- ^ @"ROUTED"@
  | OrdStatus'NEW -- ^ @"NEW"@
  | OrdStatus'PENDING_CANCEL -- ^ @"PENDING_CANCEL"@
  | OrdStatus'PARTIALLY_FILLED -- ^ @"PARTIALLY_FILLED"@
  | OrdStatus'FILLED -- ^ @"FILLED"@
  | OrdStatus'CANCELED -- ^ @"CANCELED"@
  | OrdStatus'REJECTED -- ^ @"REJECTED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdStatus where toJSON = A.toJSON . fromOrdStatus
instance A.FromJSON OrdStatus where parseJSON o = P.either P.fail (pure . P.id) . toOrdStatus =<< A.parseJSON o
instance WH.ToHttpApiData OrdStatus where toQueryParam = WH.toQueryParam . fromOrdStatus
instance WH.FromHttpApiData OrdStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdStatus
instance MimeRender MimeMultipartFormData OrdStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdStatus' enum
fromOrdStatus :: OrdStatus -> Text
fromOrdStatus = \case
  OrdStatus'RECEIVED -> "RECEIVED"
  OrdStatus'ROUTING -> "ROUTING"
  OrdStatus'ROUTED -> "ROUTED"
  OrdStatus'NEW -> "NEW"
  OrdStatus'PENDING_CANCEL -> "PENDING_CANCEL"
  OrdStatus'PARTIALLY_FILLED -> "PARTIALLY_FILLED"
  OrdStatus'FILLED -> "FILLED"
  OrdStatus'CANCELED -> "CANCELED"
  OrdStatus'REJECTED -> "REJECTED"

-- | parse 'OrdStatus' enum
toOrdStatus :: Text -> P.Either String OrdStatus
toOrdStatus = \case
  "RECEIVED" -> P.Right OrdStatus'RECEIVED
  "ROUTING" -> P.Right OrdStatus'ROUTING
  "ROUTED" -> P.Right OrdStatus'ROUTED
  "NEW" -> P.Right OrdStatus'NEW
  "PENDING_CANCEL" -> P.Right OrdStatus'PENDING_CANCEL
  "PARTIALLY_FILLED" -> P.Right OrdStatus'PARTIALLY_FILLED
  "FILLED" -> P.Right OrdStatus'FILLED
  "CANCELED" -> P.Right OrdStatus'CANCELED
  "REJECTED" -> P.Right OrdStatus'REJECTED
  s -> P.Left $ "toOrdStatus: enum parse failure: " P.++ P.show s


-- ** OrdType

-- | Enum of 'Text' . 
-- Order types are documented in the separate section: <a href=\"#oeml-order-params-type\">OEML / Starter Guide / Order parameters / Order type</a> 
data OrdType
  = OrdType'LIMIT -- ^ @"LIMIT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdType where toJSON = A.toJSON . fromOrdType
instance A.FromJSON OrdType where parseJSON o = P.either P.fail (pure . P.id) . toOrdType =<< A.parseJSON o
instance WH.ToHttpApiData OrdType where toQueryParam = WH.toQueryParam . fromOrdType
instance WH.FromHttpApiData OrdType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdType
instance MimeRender MimeMultipartFormData OrdType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdType' enum
fromOrdType :: OrdType -> Text
fromOrdType = \case
  OrdType'LIMIT -> "LIMIT"

-- | parse 'OrdType' enum
toOrdType :: Text -> P.Either String OrdType
toOrdType = \case
  "LIMIT" -> P.Right OrdType'LIMIT
  s -> P.Left $ "toOrdType: enum parse failure: " P.++ P.show s


-- ** Severity

-- | Enum of 'Text' . 
-- Severity of the message.
data Severity
  = Severity'INFO -- ^ @"INFO"@
  | Severity'WARNING -- ^ @"WARNING"@
  | Severity'ERROR -- ^ @"ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON Severity where toJSON = A.toJSON . fromSeverity
instance A.FromJSON Severity where parseJSON o = P.either P.fail (pure . P.id) . toSeverity =<< A.parseJSON o
instance WH.ToHttpApiData Severity where toQueryParam = WH.toQueryParam . fromSeverity
instance WH.FromHttpApiData Severity where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSeverity
instance MimeRender MimeMultipartFormData Severity where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'Severity' enum
fromSeverity :: Severity -> Text
fromSeverity = \case
  Severity'INFO -> "INFO"
  Severity'WARNING -> "WARNING"
  Severity'ERROR -> "ERROR"

-- | parse 'Severity' enum
toSeverity :: Text -> P.Either String Severity
toSeverity = \case
  "INFO" -> P.Right Severity'INFO
  "WARNING" -> P.Right Severity'WARNING
  "ERROR" -> P.Right Severity'ERROR
  s -> P.Left $ "toSeverity: enum parse failure: " P.++ P.show s


-- ** TimeInForce

-- | Enum of 'Text' . 
-- Order time in force options are documented in the separate section: <a href=\"#oeml-order-params-tif\">OEML / Starter Guide / Order parameters / Time in force</a> 
data TimeInForce
  = TimeInForce'GOOD_TILL_CANCEL -- ^ @"GOOD_TILL_CANCEL"@
  | TimeInForce'GOOD_TILL_TIME_EXCHANGE -- ^ @"GOOD_TILL_TIME_EXCHANGE"@
  | TimeInForce'GOOD_TILL_TIME_OMS -- ^ @"GOOD_TILL_TIME_OMS"@
  | TimeInForce'FILL_OR_KILL -- ^ @"FILL_OR_KILL"@
  | TimeInForce'IMMEDIATE_OR_CANCEL -- ^ @"IMMEDIATE_OR_CANCEL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TimeInForce where toJSON = A.toJSON . fromTimeInForce
instance A.FromJSON TimeInForce where parseJSON o = P.either P.fail (pure . P.id) . toTimeInForce =<< A.parseJSON o
instance WH.ToHttpApiData TimeInForce where toQueryParam = WH.toQueryParam . fromTimeInForce
instance WH.FromHttpApiData TimeInForce where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTimeInForce
instance MimeRender MimeMultipartFormData TimeInForce where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TimeInForce' enum
fromTimeInForce :: TimeInForce -> Text
fromTimeInForce = \case
  TimeInForce'GOOD_TILL_CANCEL -> "GOOD_TILL_CANCEL"
  TimeInForce'GOOD_TILL_TIME_EXCHANGE -> "GOOD_TILL_TIME_EXCHANGE"
  TimeInForce'GOOD_TILL_TIME_OMS -> "GOOD_TILL_TIME_OMS"
  TimeInForce'FILL_OR_KILL -> "FILL_OR_KILL"
  TimeInForce'IMMEDIATE_OR_CANCEL -> "IMMEDIATE_OR_CANCEL"

-- | parse 'TimeInForce' enum
toTimeInForce :: Text -> P.Either String TimeInForce
toTimeInForce = \case
  "GOOD_TILL_CANCEL" -> P.Right TimeInForce'GOOD_TILL_CANCEL
  "GOOD_TILL_TIME_EXCHANGE" -> P.Right TimeInForce'GOOD_TILL_TIME_EXCHANGE
  "GOOD_TILL_TIME_OMS" -> P.Right TimeInForce'GOOD_TILL_TIME_OMS
  "FILL_OR_KILL" -> P.Right TimeInForce'FILL_OR_KILL
  "IMMEDIATE_OR_CANCEL" -> P.Right TimeInForce'IMMEDIATE_OR_CANCEL
  s -> P.Left $ "toTimeInForce: enum parse failure: " P.++ P.show s



