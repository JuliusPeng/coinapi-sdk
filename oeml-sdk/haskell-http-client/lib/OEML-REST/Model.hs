{-
   OEML - REST API

   This section will provide necessary information about the `CoinAPI OEML REST API` protocol. 

   OpenAPI Version: 3.0.0
   OEML - REST API API version: v1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OEML-REST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OEML-REST.Model where

import OEML-REST.Core
import OEML-REST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** ClientOrderId
newtype ClientOrderId = ClientOrderId { unClientOrderId :: Text } deriving (P.Eq, P.Show)

-- ** ExchangeId
newtype ExchangeId = ExchangeId { unExchangeId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Balance
-- | Balance
data Balance = Balance
  { balanceType :: !(Maybe Text) -- ^ "type" - Result type.
  , balanceExchangeName :: !(Maybe Text) -- ^ "exchange_name" - Exchange name.
  , balanceData :: !(Maybe [BalanceData]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Balance
instance A.FromJSON Balance where
  parseJSON = A.withObject "Balance" $ \o ->
    Balance
      <$> (o .:? "type")
      <*> (o .:? "exchange_name")
      <*> (o .:? "data")

-- | ToJSON Balance
instance A.ToJSON Balance where
  toJSON Balance {..} =
   _omitNulls
      [ "type" .= balanceType
      , "exchange_name" .= balanceExchangeName
      , "data" .= balanceData
      ]


-- | Construct a value of type 'Balance' (by applying it's required fields, if any)
mkBalance
  :: Balance
mkBalance =
  Balance
  { balanceType = Nothing
  , balanceExchangeName = Nothing
  , balanceData = Nothing
  }

-- ** BalanceData
-- | BalanceData
data BalanceData = BalanceData
  { balanceDataId :: !(Maybe Text) -- ^ "id" - Exchange identifier.
  , balanceDataSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - Exchange currency code.
  , balanceDataSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - CoinAPI currency code.
  , balanceDataBalance :: !(Maybe Float) -- ^ "balance" - Value of the current total currency balance on the exchange.
  , balanceDataAvailable :: !(Maybe Float) -- ^ "available" - Value of the current available currency balance on the exchange that can be used as collateral.
  , balanceDataLocked :: !(Maybe Float) -- ^ "locked" - Value of the current locked currency balance by the exchange.
  , balanceDataUpdateOrigin :: !(Maybe E'UpdateOrigin) -- ^ "update_origin" - Source of the last modification. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BalanceData
instance A.FromJSON BalanceData where
  parseJSON = A.withObject "BalanceData" $ \o ->
    BalanceData
      <$> (o .:? "id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:? "balance")
      <*> (o .:? "available")
      <*> (o .:? "locked")
      <*> (o .:? "update_origin")

-- | ToJSON BalanceData
instance A.ToJSON BalanceData where
  toJSON BalanceData {..} =
   _omitNulls
      [ "id" .= balanceDataId
      , "symbol_exchange" .= balanceDataSymbolExchange
      , "symbol_coinapi" .= balanceDataSymbolCoinapi
      , "balance" .= balanceDataBalance
      , "available" .= balanceDataAvailable
      , "locked" .= balanceDataLocked
      , "update_origin" .= balanceDataUpdateOrigin
      ]


-- | Construct a value of type 'BalanceData' (by applying it's required fields, if any)
mkBalanceData
  :: BalanceData
mkBalanceData =
  BalanceData
  { balanceDataId = Nothing
  , balanceDataSymbolExchange = Nothing
  , balanceDataSymbolCoinapi = Nothing
  , balanceDataBalance = Nothing
  , balanceDataAvailable = Nothing
  , balanceDataLocked = Nothing
  , balanceDataUpdateOrigin = Nothing
  }

-- ** CreateOrderValidationError
-- | CreateOrderValidationError
-- Create order validation error (response)
-- 
data CreateOrderValidationError = CreateOrderValidationError
  { createOrderValidationErrorType :: !(Maybe Text) -- ^ "type"
  , createOrderValidationErrorTitle :: !(Maybe Text) -- ^ "title"
  , createOrderValidationErrorStatus :: !(Maybe Double) -- ^ "status"
  , createOrderValidationErrorTraceId :: !(Maybe Text) -- ^ "traceId"
  , createOrderValidationErrorErrors :: !(Maybe Text) -- ^ "errors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateOrderValidationError
instance A.FromJSON CreateOrderValidationError where
  parseJSON = A.withObject "CreateOrderValidationError" $ \o ->
    CreateOrderValidationError
      <$> (o .:? "type")
      <*> (o .:? "title")
      <*> (o .:? "status")
      <*> (o .:? "traceId")
      <*> (o .:? "errors")

-- | ToJSON CreateOrderValidationError
instance A.ToJSON CreateOrderValidationError where
  toJSON CreateOrderValidationError {..} =
   _omitNulls
      [ "type" .= createOrderValidationErrorType
      , "title" .= createOrderValidationErrorTitle
      , "status" .= createOrderValidationErrorStatus
      , "traceId" .= createOrderValidationErrorTraceId
      , "errors" .= createOrderValidationErrorErrors
      ]


-- | Construct a value of type 'CreateOrderValidationError' (by applying it's required fields, if any)
mkCreateOrderValidationError
  :: CreateOrderValidationError
mkCreateOrderValidationError =
  CreateOrderValidationError
  { createOrderValidationErrorType = Nothing
  , createOrderValidationErrorTitle = Nothing
  , createOrderValidationErrorStatus = Nothing
  , createOrderValidationErrorTraceId = Nothing
  , createOrderValidationErrorErrors = Nothing
  }

-- ** ExecutionReport
-- | ExecutionReport
data ExecutionReport = ExecutionReport
  { executionReportExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier.
  , executionReportClientOrderId :: !(Text) -- ^ /Required/ "client_order_id" - Unique identifier for the order assigned by the &#x60;OEML API&#x60; client.
  , executionReportSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - Exchange symbol. One of the properties (&#x60;symbol_exchange&#x60;, &#x60;symbol_coinapi&#x60;) is required to identify the market for the order.
  , executionReportSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - CoinAPI symbol. One of the properties (&#x60;symbol_exchange&#x60;, &#x60;symbol_coinapi&#x60;) is required to identify the market for the order.
  , executionReportAmountOrder :: !(Double) -- ^ /Required/ "amount_order" - Order quantity.
  , executionReportPrice :: !(Double) -- ^ /Required/ "price" - Order price.
  , executionReportSide :: !(OrdSide) -- ^ /Required/ "side"
  , executionReportOrderType :: !(OrdType) -- ^ /Required/ "order_type"
  , executionReportTimeInForce :: !(TimeInForce) -- ^ /Required/ "time_in_force"
  , executionReportExpireTime :: !(Maybe Date) -- ^ "expire_time" - Expiration time. Conditionaly required for orders with time_in_force &#x3D; &#x60;GOOD_TILL_TIME_EXCHANGE&#x60; or &#x60;GOOD_TILL_TIME_OEML&#x60;.
  , executionReportExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - Order execution instructions are documented in the separate section: &lt;a href&#x3D;\&quot;#oeml-order-params-exec\&quot;&gt;OEML / Starter Guide / Order parameters / Execution instructions&lt;/a&gt;
  , executionReportClientOrderIdFormatExchange :: !(Maybe Text) -- ^ "client_order_id_format_exchange" - Hash client id
  , executionReportExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Exchange order id
  , executionReportAmountOpen :: !(Maybe Double) -- ^ "amount_open" - Amount open
  , executionReportAmountFilled :: !(Maybe Double) -- ^ "amount_filled" - Amount filled
  , executionReportStatus :: !(Maybe OrdStatus) -- ^ "status"
  , executionReportTimeOrder :: !(Maybe [[Text]]) -- ^ "time_order" - History of order status changes
  , executionReportErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecutionReport
instance A.FromJSON ExecutionReport where
  parseJSON = A.withObject "ExecutionReport" $ \o ->
    ExecutionReport
      <$> (o .:  "exchange_id")
      <*> (o .:  "client_order_id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:  "amount_order")
      <*> (o .:  "price")
      <*> (o .:  "side")
      <*> (o .:  "order_type")
      <*> (o .:  "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")
      <*> (o .:? "client_order_id_format_exchange")
      <*> (o .:? "exchange_order_id")
      <*> (o .:? "amount_open")
      <*> (o .:? "amount_filled")
      <*> (o .:? "status")
      <*> (o .:? "time_order")
      <*> (o .:? "error_message")

-- | ToJSON ExecutionReport
instance A.ToJSON ExecutionReport where
  toJSON ExecutionReport {..} =
   _omitNulls
      [ "exchange_id" .= executionReportExchangeId
      , "client_order_id" .= executionReportClientOrderId
      , "symbol_exchange" .= executionReportSymbolExchange
      , "symbol_coinapi" .= executionReportSymbolCoinapi
      , "amount_order" .= executionReportAmountOrder
      , "price" .= executionReportPrice
      , "side" .= executionReportSide
      , "order_type" .= executionReportOrderType
      , "time_in_force" .= executionReportTimeInForce
      , "expire_time" .= executionReportExpireTime
      , "exec_inst" .= executionReportExecInst
      , "client_order_id_format_exchange" .= executionReportClientOrderIdFormatExchange
      , "exchange_order_id" .= executionReportExchangeOrderId
      , "amount_open" .= executionReportAmountOpen
      , "amount_filled" .= executionReportAmountFilled
      , "status" .= executionReportStatus
      , "time_order" .= executionReportTimeOrder
      , "error_message" .= executionReportErrorMessage
      ]


-- | Construct a value of type 'ExecutionReport' (by applying it's required fields, if any)
mkExecutionReport
  :: Text -- ^ 'executionReportExchangeId': Exchange identifier.
  -> Text -- ^ 'executionReportClientOrderId': Unique identifier for the order assigned by the `OEML API` client.
  -> Double -- ^ 'executionReportAmountOrder': Order quantity.
  -> Double -- ^ 'executionReportPrice': Order price.
  -> OrdSide -- ^ 'executionReportSide' 
  -> OrdType -- ^ 'executionReportOrderType' 
  -> TimeInForce -- ^ 'executionReportTimeInForce' 
  -> ExecutionReport
mkExecutionReport executionReportExchangeId executionReportClientOrderId executionReportAmountOrder executionReportPrice executionReportSide executionReportOrderType executionReportTimeInForce =
  ExecutionReport
  { executionReportExchangeId
  , executionReportClientOrderId
  , executionReportSymbolExchange = Nothing
  , executionReportSymbolCoinapi = Nothing
  , executionReportAmountOrder
  , executionReportPrice
  , executionReportSide
  , executionReportOrderType
  , executionReportTimeInForce
  , executionReportExpireTime = Nothing
  , executionReportExecInst = Nothing
  , executionReportClientOrderIdFormatExchange = Nothing
  , executionReportExchangeOrderId = Nothing
  , executionReportAmountOpen = Nothing
  , executionReportAmountFilled = Nothing
  , executionReportStatus = Nothing
  , executionReportTimeOrder = Nothing
  , executionReportErrorMessage = Nothing
  }

-- ** ExecutionReportAllOf
-- | ExecutionReportAllOf
-- The order execution report message.
data ExecutionReportAllOf = ExecutionReportAllOf
  { executionReportAllOfClientOrderIdFormatExchange :: !(Maybe Text) -- ^ "client_order_id_format_exchange" - Hash client id
  , executionReportAllOfExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Exchange order id
  , executionReportAllOfAmountOpen :: !(Maybe Double) -- ^ "amount_open" - Amount open
  , executionReportAllOfAmountFilled :: !(Maybe Double) -- ^ "amount_filled" - Amount filled
  , executionReportAllOfStatus :: !(Maybe OrdStatus) -- ^ "status"
  , executionReportAllOfTimeOrder :: !(Maybe [[Text]]) -- ^ "time_order" - History of order status changes
  , executionReportAllOfErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecutionReportAllOf
instance A.FromJSON ExecutionReportAllOf where
  parseJSON = A.withObject "ExecutionReportAllOf" $ \o ->
    ExecutionReportAllOf
      <$> (o .:? "client_order_id_format_exchange")
      <*> (o .:? "exchange_order_id")
      <*> (o .:? "amount_open")
      <*> (o .:? "amount_filled")
      <*> (o .:? "status")
      <*> (o .:? "time_order")
      <*> (o .:? "error_message")

-- | ToJSON ExecutionReportAllOf
instance A.ToJSON ExecutionReportAllOf where
  toJSON ExecutionReportAllOf {..} =
   _omitNulls
      [ "client_order_id_format_exchange" .= executionReportAllOfClientOrderIdFormatExchange
      , "exchange_order_id" .= executionReportAllOfExchangeOrderId
      , "amount_open" .= executionReportAllOfAmountOpen
      , "amount_filled" .= executionReportAllOfAmountFilled
      , "status" .= executionReportAllOfStatus
      , "time_order" .= executionReportAllOfTimeOrder
      , "error_message" .= executionReportAllOfErrorMessage
      ]


-- | Construct a value of type 'ExecutionReportAllOf' (by applying it's required fields, if any)
mkExecutionReportAllOf
  :: ExecutionReportAllOf
mkExecutionReportAllOf =
  ExecutionReportAllOf
  { executionReportAllOfClientOrderIdFormatExchange = Nothing
  , executionReportAllOfExchangeOrderId = Nothing
  , executionReportAllOfAmountOpen = Nothing
  , executionReportAllOfAmountFilled = Nothing
  , executionReportAllOfStatus = Nothing
  , executionReportAllOfTimeOrder = Nothing
  , executionReportAllOfErrorMessage = Nothing
  }

-- ** Message
-- | Message
-- Success or error message carrier.
-- 
data Message = Message
  { messageType :: !(Maybe Text) -- ^ "type" - Type of message.
  , messageSeverity :: !(Maybe Severity) -- ^ "severity"
  , messageExchangeId :: !(Maybe Text) -- ^ "exchange_id" - If message related exchange then identifier of this exchange.
  , messageMessage :: !(Maybe Text) -- ^ "message" - Sucess message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Message
instance A.FromJSON Message where
  parseJSON = A.withObject "Message" $ \o ->
    Message
      <$> (o .:? "type")
      <*> (o .:? "severity")
      <*> (o .:? "exchange_id")
      <*> (o .:? "message")

-- | ToJSON Message
instance A.ToJSON Message where
  toJSON Message {..} =
   _omitNulls
      [ "type" .= messageType
      , "severity" .= messageSeverity
      , "exchange_id" .= messageExchangeId
      , "message" .= messageMessage
      ]


-- | Construct a value of type 'Message' (by applying it's required fields, if any)
mkMessage
  :: Message
mkMessage =
  Message
  { messageType = Nothing
  , messageSeverity = Nothing
  , messageExchangeId = Nothing
  , messageMessage = Nothing
  }

-- ** NewOrderSingle
-- | NewOrderSingle
-- The new order message.
data NewOrderSingle = NewOrderSingle
  { newOrderSingleExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier.
  , newOrderSingleClientOrderId :: !(Text) -- ^ /Required/ "client_order_id" - Unique identifier for the order assigned by the &#x60;OEML API&#x60; client.
  , newOrderSingleSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - Exchange symbol. One of the properties (&#x60;symbol_exchange&#x60;, &#x60;symbol_coinapi&#x60;) is required to identify the market for the order.
  , newOrderSingleSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - CoinAPI symbol. One of the properties (&#x60;symbol_exchange&#x60;, &#x60;symbol_coinapi&#x60;) is required to identify the market for the order.
  , newOrderSingleAmountOrder :: !(Double) -- ^ /Required/ "amount_order" - Order quantity.
  , newOrderSinglePrice :: !(Double) -- ^ /Required/ "price" - Order price.
  , newOrderSingleSide :: !(OrdSide) -- ^ /Required/ "side"
  , newOrderSingleOrderType :: !(OrdType) -- ^ /Required/ "order_type"
  , newOrderSingleTimeInForce :: !(TimeInForce) -- ^ /Required/ "time_in_force"
  , newOrderSingleExpireTime :: !(Maybe Date) -- ^ "expire_time" - Expiration time. Conditionaly required for orders with time_in_force &#x3D; &#x60;GOOD_TILL_TIME_EXCHANGE&#x60; or &#x60;GOOD_TILL_TIME_OEML&#x60;.
  , newOrderSingleExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - Order execution instructions are documented in the separate section: &lt;a href&#x3D;\&quot;#oeml-order-params-exec\&quot;&gt;OEML / Starter Guide / Order parameters / Execution instructions&lt;/a&gt;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NewOrderSingle
instance A.FromJSON NewOrderSingle where
  parseJSON = A.withObject "NewOrderSingle" $ \o ->
    NewOrderSingle
      <$> (o .:  "exchange_id")
      <*> (o .:  "client_order_id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:  "amount_order")
      <*> (o .:  "price")
      <*> (o .:  "side")
      <*> (o .:  "order_type")
      <*> (o .:  "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")

-- | ToJSON NewOrderSingle
instance A.ToJSON NewOrderSingle where
  toJSON NewOrderSingle {..} =
   _omitNulls
      [ "exchange_id" .= newOrderSingleExchangeId
      , "client_order_id" .= newOrderSingleClientOrderId
      , "symbol_exchange" .= newOrderSingleSymbolExchange
      , "symbol_coinapi" .= newOrderSingleSymbolCoinapi
      , "amount_order" .= newOrderSingleAmountOrder
      , "price" .= newOrderSinglePrice
      , "side" .= newOrderSingleSide
      , "order_type" .= newOrderSingleOrderType
      , "time_in_force" .= newOrderSingleTimeInForce
      , "expire_time" .= newOrderSingleExpireTime
      , "exec_inst" .= newOrderSingleExecInst
      ]


-- | Construct a value of type 'NewOrderSingle' (by applying it's required fields, if any)
mkNewOrderSingle
  :: Text -- ^ 'newOrderSingleExchangeId': Exchange identifier.
  -> Text -- ^ 'newOrderSingleClientOrderId': Unique identifier for the order assigned by the `OEML API` client.
  -> Double -- ^ 'newOrderSingleAmountOrder': Order quantity.
  -> Double -- ^ 'newOrderSinglePrice': Order price.
  -> OrdSide -- ^ 'newOrderSingleSide' 
  -> OrdType -- ^ 'newOrderSingleOrderType' 
  -> TimeInForce -- ^ 'newOrderSingleTimeInForce' 
  -> NewOrderSingle
mkNewOrderSingle newOrderSingleExchangeId newOrderSingleClientOrderId newOrderSingleAmountOrder newOrderSinglePrice newOrderSingleSide newOrderSingleOrderType newOrderSingleTimeInForce =
  NewOrderSingle
  { newOrderSingleExchangeId
  , newOrderSingleClientOrderId
  , newOrderSingleSymbolExchange = Nothing
  , newOrderSingleSymbolCoinapi = Nothing
  , newOrderSingleAmountOrder
  , newOrderSinglePrice
  , newOrderSingleSide
  , newOrderSingleOrderType
  , newOrderSingleTimeInForce
  , newOrderSingleExpireTime = Nothing
  , newOrderSingleExecInst = Nothing
  }

-- ** OrderCancelAllRequest
-- | OrderCancelAllRequest
data OrderCancelAllRequest = OrderCancelAllRequest
  { orderCancelAllRequestExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier from which active orders should be canceled.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderCancelAllRequest
instance A.FromJSON OrderCancelAllRequest where
  parseJSON = A.withObject "OrderCancelAllRequest" $ \o ->
    OrderCancelAllRequest
      <$> (o .:  "exchange_id")

-- | ToJSON OrderCancelAllRequest
instance A.ToJSON OrderCancelAllRequest where
  toJSON OrderCancelAllRequest {..} =
   _omitNulls
      [ "exchange_id" .= orderCancelAllRequestExchangeId
      ]


-- | Construct a value of type 'OrderCancelAllRequest' (by applying it's required fields, if any)
mkOrderCancelAllRequest
  :: Text -- ^ 'orderCancelAllRequestExchangeId': Exchange identifier from which active orders should be canceled.
  -> OrderCancelAllRequest
mkOrderCancelAllRequest orderCancelAllRequestExchangeId =
  OrderCancelAllRequest
  { orderCancelAllRequestExchangeId
  }

-- ** OrderCancelSingleRequest
-- | OrderCancelSingleRequest
data OrderCancelSingleRequest = OrderCancelSingleRequest
  { orderCancelSingleRequestExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange name
  , orderCancelSingleRequestExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Order Id
  , orderCancelSingleRequestClientOrderId :: !(Maybe Text) -- ^ "client_order_id" - Client order Id
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderCancelSingleRequest
instance A.FromJSON OrderCancelSingleRequest where
  parseJSON = A.withObject "OrderCancelSingleRequest" $ \o ->
    OrderCancelSingleRequest
      <$> (o .:? "exchange_id")
      <*> (o .:? "exchange_order_id")
      <*> (o .:? "client_order_id")

-- | ToJSON OrderCancelSingleRequest
instance A.ToJSON OrderCancelSingleRequest where
  toJSON OrderCancelSingleRequest {..} =
   _omitNulls
      [ "exchange_id" .= orderCancelSingleRequestExchangeId
      , "exchange_order_id" .= orderCancelSingleRequestExchangeOrderId
      , "client_order_id" .= orderCancelSingleRequestClientOrderId
      ]


-- | Construct a value of type 'OrderCancelSingleRequest' (by applying it's required fields, if any)
mkOrderCancelSingleRequest
  :: OrderCancelSingleRequest
mkOrderCancelSingleRequest =
  OrderCancelSingleRequest
  { orderCancelSingleRequestExchangeId = Nothing
  , orderCancelSingleRequestExchangeOrderId = Nothing
  , orderCancelSingleRequestClientOrderId = Nothing
  }

-- ** Position
-- | Position
data Position = Position
  { positionType :: !(Maybe Text) -- ^ "type" - Result type.
  , positionExchangeName :: !(Maybe Text) -- ^ "exchange_name" - Name of exchange.
  , positionData :: !(Maybe [PositionData]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Position
instance A.FromJSON Position where
  parseJSON = A.withObject "Position" $ \o ->
    Position
      <$> (o .:? "type")
      <*> (o .:? "exchange_name")
      <*> (o .:? "data")

-- | ToJSON Position
instance A.ToJSON Position where
  toJSON Position {..} =
   _omitNulls
      [ "type" .= positionType
      , "exchange_name" .= positionExchangeName
      , "data" .= positionData
      ]


-- | Construct a value of type 'Position' (by applying it's required fields, if any)
mkPosition
  :: Position
mkPosition =
  Position
  { positionType = Nothing
  , positionExchangeName = Nothing
  , positionData = Nothing
  }

-- ** PositionData
-- | PositionData
data PositionData = PositionData
  { positionDataId :: !(Maybe Text) -- ^ "id" - Unique position ID
  , positionDataSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - The contract for this position.
  , positionDataSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - The coinapi contract for this position.
  , positionDataAvgEntryPrice :: !(Maybe Double) -- ^ "avg_entry_price"
  , positionDataQuantity :: !(Maybe Double) -- ^ "quantity" - The current position amount in contracts.
  , positionDataIsBuy :: !(Maybe Bool) -- ^ "is_buy"
  , positionDataUnrealisedPnL :: !(Maybe Double) -- ^ "unrealised_pn_l" - Unrealised PNL is all the unrealised profit or loss coming from your portfolio&#39;s open positions.
  , positionDataLeverage :: !(Maybe Double) -- ^ "leverage" - 1 / initMarginReq.
  , positionDataCrossMargin :: !(Maybe Bool) -- ^ "cross_margin" - True/false depending on whether you set cross margin on this position.
  , positionDataLiquidationPrice :: !(Maybe Double) -- ^ "liquidation_price" - Once markPrice reaches this price, this position will be liquidated.
  , positionDataRawData :: !(Maybe Text) -- ^ "raw_data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PositionData
instance A.FromJSON PositionData where
  parseJSON = A.withObject "PositionData" $ \o ->
    PositionData
      <$> (o .:? "id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:? "avg_entry_price")
      <*> (o .:? "quantity")
      <*> (o .:? "is_buy")
      <*> (o .:? "unrealised_pn_l")
      <*> (o .:? "leverage")
      <*> (o .:? "cross_margin")
      <*> (o .:? "liquidation_price")
      <*> (o .:? "raw_data")

-- | ToJSON PositionData
instance A.ToJSON PositionData where
  toJSON PositionData {..} =
   _omitNulls
      [ "id" .= positionDataId
      , "symbol_exchange" .= positionDataSymbolExchange
      , "symbol_coinapi" .= positionDataSymbolCoinapi
      , "avg_entry_price" .= positionDataAvgEntryPrice
      , "quantity" .= positionDataQuantity
      , "is_buy" .= positionDataIsBuy
      , "unrealised_pn_l" .= positionDataUnrealisedPnL
      , "leverage" .= positionDataLeverage
      , "cross_margin" .= positionDataCrossMargin
      , "liquidation_price" .= positionDataLiquidationPrice
      , "raw_data" .= positionDataRawData
      ]


-- | Construct a value of type 'PositionData' (by applying it's required fields, if any)
mkPositionData
  :: PositionData
mkPositionData =
  PositionData
  { positionDataId = Nothing
  , positionDataSymbolExchange = Nothing
  , positionDataSymbolCoinapi = Nothing
  , positionDataAvgEntryPrice = Nothing
  , positionDataQuantity = Nothing
  , positionDataIsBuy = Nothing
  , positionDataUnrealisedPnL = Nothing
  , positionDataLeverage = Nothing
  , positionDataCrossMargin = Nothing
  , positionDataLiquidationPrice = Nothing
  , positionDataRawData = Nothing
  }


-- * Enums


-- ** E'ExecInst

-- | Enum of 'Text'
data E'ExecInst
  = E'ExecInst'MAKER_OR_CANCEL -- ^ @"MAKER_OR_CANCEL"@
  | E'ExecInst'AUCTION_ONLY -- ^ @"AUCTION_ONLY"@
  | E'ExecInst'INDICATION_OF_INTEREST -- ^ @"INDICATION_OF_INTEREST"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ExecInst where toJSON = A.toJSON . fromE'ExecInst
instance A.FromJSON E'ExecInst where parseJSON o = P.either P.fail (pure . P.id) . toE'ExecInst =<< A.parseJSON o
instance WH.ToHttpApiData E'ExecInst where toQueryParam = WH.toQueryParam . fromE'ExecInst
instance WH.FromHttpApiData E'ExecInst where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ExecInst
instance MimeRender MimeMultipartFormData E'ExecInst where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ExecInst' enum
fromE'ExecInst :: E'ExecInst -> Text
fromE'ExecInst = \case
  E'ExecInst'MAKER_OR_CANCEL -> "MAKER_OR_CANCEL"
  E'ExecInst'AUCTION_ONLY -> "AUCTION_ONLY"
  E'ExecInst'INDICATION_OF_INTEREST -> "INDICATION_OF_INTEREST"

-- | parse 'E'ExecInst' enum
toE'ExecInst :: Text -> P.Either String E'ExecInst
toE'ExecInst = \case
  "MAKER_OR_CANCEL" -> P.Right E'ExecInst'MAKER_OR_CANCEL
  "AUCTION_ONLY" -> P.Right E'ExecInst'AUCTION_ONLY
  "INDICATION_OF_INTEREST" -> P.Right E'ExecInst'INDICATION_OF_INTEREST
  s -> P.Left $ "toE'ExecInst: enum parse failure: " P.++ P.show s


-- ** E'UpdateOrigin

-- | Enum of 'Text' . 
-- Source of the last modification. 
data E'UpdateOrigin
  = E'UpdateOrigin'INITIALIZATION -- ^ @"INITIALIZATION"@
  | E'UpdateOrigin'BALANCE_MANAGER -- ^ @"BALANCE_MANAGER"@
  | E'UpdateOrigin'EXCHANGE -- ^ @"EXCHANGE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'UpdateOrigin where toJSON = A.toJSON . fromE'UpdateOrigin
instance A.FromJSON E'UpdateOrigin where parseJSON o = P.either P.fail (pure . P.id) . toE'UpdateOrigin =<< A.parseJSON o
instance WH.ToHttpApiData E'UpdateOrigin where toQueryParam = WH.toQueryParam . fromE'UpdateOrigin
instance WH.FromHttpApiData E'UpdateOrigin where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'UpdateOrigin
instance MimeRender MimeMultipartFormData E'UpdateOrigin where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'UpdateOrigin' enum
fromE'UpdateOrigin :: E'UpdateOrigin -> Text
fromE'UpdateOrigin = \case
  E'UpdateOrigin'INITIALIZATION -> "INITIALIZATION"
  E'UpdateOrigin'BALANCE_MANAGER -> "BALANCE_MANAGER"
  E'UpdateOrigin'EXCHANGE -> "EXCHANGE"

-- | parse 'E'UpdateOrigin' enum
toE'UpdateOrigin :: Text -> P.Either String E'UpdateOrigin
toE'UpdateOrigin = \case
  "INITIALIZATION" -> P.Right E'UpdateOrigin'INITIALIZATION
  "BALANCE_MANAGER" -> P.Right E'UpdateOrigin'BALANCE_MANAGER
  "EXCHANGE" -> P.Right E'UpdateOrigin'EXCHANGE
  s -> P.Left $ "toE'UpdateOrigin: enum parse failure: " P.++ P.show s


-- ** OrdSide

-- | Enum of 'Text' . 
-- Side of order. 
data OrdSide
  = OrdSide'BUY -- ^ @"BUY"@
  | OrdSide'SELL -- ^ @"SELL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdSide where toJSON = A.toJSON . fromOrdSide
instance A.FromJSON OrdSide where parseJSON o = P.either P.fail (pure . P.id) . toOrdSide =<< A.parseJSON o
instance WH.ToHttpApiData OrdSide where toQueryParam = WH.toQueryParam . fromOrdSide
instance WH.FromHttpApiData OrdSide where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdSide
instance MimeRender MimeMultipartFormData OrdSide where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdSide' enum
fromOrdSide :: OrdSide -> Text
fromOrdSide = \case
  OrdSide'BUY -> "BUY"
  OrdSide'SELL -> "SELL"

-- | parse 'OrdSide' enum
toOrdSide :: Text -> P.Either String OrdSide
toOrdSide = \case
  "BUY" -> P.Right OrdSide'BUY
  "SELL" -> P.Right OrdSide'SELL
  s -> P.Left $ "toOrdSide: enum parse failure: " P.++ P.show s


-- ** OrdStatus

-- | Enum of 'Text' . 
-- Order statuses and the lifecycle are documented in the separate section: <a href=\"#oeml-order-lifecycle\">OEML / Starter Guide / Order Lifecycle</a> 
data OrdStatus
  = OrdStatus'RECEIVED -- ^ @"RECEIVED"@
  | OrdStatus'ROUTING -- ^ @"ROUTING"@
  | OrdStatus'ROUTED -- ^ @"ROUTED"@
  | OrdStatus'NEW -- ^ @"NEW"@
  | OrdStatus'PENDING_CANCEL -- ^ @"PENDING_CANCEL"@
  | OrdStatus'PARTIALLY_FILLED -- ^ @"PARTIALLY_FILLED"@
  | OrdStatus'FILLED -- ^ @"FILLED"@
  | OrdStatus'CANCELED -- ^ @"CANCELED"@
  | OrdStatus'REJECTED -- ^ @"REJECTED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdStatus where toJSON = A.toJSON . fromOrdStatus
instance A.FromJSON OrdStatus where parseJSON o = P.either P.fail (pure . P.id) . toOrdStatus =<< A.parseJSON o
instance WH.ToHttpApiData OrdStatus where toQueryParam = WH.toQueryParam . fromOrdStatus
instance WH.FromHttpApiData OrdStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdStatus
instance MimeRender MimeMultipartFormData OrdStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdStatus' enum
fromOrdStatus :: OrdStatus -> Text
fromOrdStatus = \case
  OrdStatus'RECEIVED -> "RECEIVED"
  OrdStatus'ROUTING -> "ROUTING"
  OrdStatus'ROUTED -> "ROUTED"
  OrdStatus'NEW -> "NEW"
  OrdStatus'PENDING_CANCEL -> "PENDING_CANCEL"
  OrdStatus'PARTIALLY_FILLED -> "PARTIALLY_FILLED"
  OrdStatus'FILLED -> "FILLED"
  OrdStatus'CANCELED -> "CANCELED"
  OrdStatus'REJECTED -> "REJECTED"

-- | parse 'OrdStatus' enum
toOrdStatus :: Text -> P.Either String OrdStatus
toOrdStatus = \case
  "RECEIVED" -> P.Right OrdStatus'RECEIVED
  "ROUTING" -> P.Right OrdStatus'ROUTING
  "ROUTED" -> P.Right OrdStatus'ROUTED
  "NEW" -> P.Right OrdStatus'NEW
  "PENDING_CANCEL" -> P.Right OrdStatus'PENDING_CANCEL
  "PARTIALLY_FILLED" -> P.Right OrdStatus'PARTIALLY_FILLED
  "FILLED" -> P.Right OrdStatus'FILLED
  "CANCELED" -> P.Right OrdStatus'CANCELED
  "REJECTED" -> P.Right OrdStatus'REJECTED
  s -> P.Left $ "toOrdStatus: enum parse failure: " P.++ P.show s


-- ** OrdType

-- | Enum of 'Text' . 
-- Order types are documented in the separate section: <a href=\"#oeml-order-params-type\">OEML / Starter Guide / Order parameters / Order type</a> 
data OrdType
  = OrdType'LIMIT -- ^ @"LIMIT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdType where toJSON = A.toJSON . fromOrdType
instance A.FromJSON OrdType where parseJSON o = P.either P.fail (pure . P.id) . toOrdType =<< A.parseJSON o
instance WH.ToHttpApiData OrdType where toQueryParam = WH.toQueryParam . fromOrdType
instance WH.FromHttpApiData OrdType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdType
instance MimeRender MimeMultipartFormData OrdType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdType' enum
fromOrdType :: OrdType -> Text
fromOrdType = \case
  OrdType'LIMIT -> "LIMIT"

-- | parse 'OrdType' enum
toOrdType :: Text -> P.Either String OrdType
toOrdType = \case
  "LIMIT" -> P.Right OrdType'LIMIT
  s -> P.Left $ "toOrdType: enum parse failure: " P.++ P.show s


-- ** Severity

-- | Enum of 'Text'
data Severity
  = Severity'INFO -- ^ @"INFO"@
  | Severity'WARNING -- ^ @"WARNING"@
  | Severity'ERROR -- ^ @"ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON Severity where toJSON = A.toJSON . fromSeverity
instance A.FromJSON Severity where parseJSON o = P.either P.fail (pure . P.id) . toSeverity =<< A.parseJSON o
instance WH.ToHttpApiData Severity where toQueryParam = WH.toQueryParam . fromSeverity
instance WH.FromHttpApiData Severity where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSeverity
instance MimeRender MimeMultipartFormData Severity where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'Severity' enum
fromSeverity :: Severity -> Text
fromSeverity = \case
  Severity'INFO -> "INFO"
  Severity'WARNING -> "WARNING"
  Severity'ERROR -> "ERROR"

-- | parse 'Severity' enum
toSeverity :: Text -> P.Either String Severity
toSeverity = \case
  "INFO" -> P.Right Severity'INFO
  "WARNING" -> P.Right Severity'WARNING
  "ERROR" -> P.Right Severity'ERROR
  s -> P.Left $ "toSeverity: enum parse failure: " P.++ P.show s


-- ** TimeInForce

-- | Enum of 'Text' . 
-- Order time in force options are documented in the separate section: <a href=\"#oeml-order-params-tif\">OEML / Starter Guide / Order parameters / Time in force</a> 
data TimeInForce
  = TimeInForce'GOOD_TILL_CANCEL -- ^ @"GOOD_TILL_CANCEL"@
  | TimeInForce'GOOD_TILL_TIME_EXCHANGE -- ^ @"GOOD_TILL_TIME_EXCHANGE"@
  | TimeInForce'GOOD_TILL_TIME_OMS -- ^ @"GOOD_TILL_TIME_OMS"@
  | TimeInForce'FILL_OR_KILL -- ^ @"FILL_OR_KILL"@
  | TimeInForce'IMMEDIATE_OR_CANCEL -- ^ @"IMMEDIATE_OR_CANCEL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TimeInForce where toJSON = A.toJSON . fromTimeInForce
instance A.FromJSON TimeInForce where parseJSON o = P.either P.fail (pure . P.id) . toTimeInForce =<< A.parseJSON o
instance WH.ToHttpApiData TimeInForce where toQueryParam = WH.toQueryParam . fromTimeInForce
instance WH.FromHttpApiData TimeInForce where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTimeInForce
instance MimeRender MimeMultipartFormData TimeInForce where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TimeInForce' enum
fromTimeInForce :: TimeInForce -> Text
fromTimeInForce = \case
  TimeInForce'GOOD_TILL_CANCEL -> "GOOD_TILL_CANCEL"
  TimeInForce'GOOD_TILL_TIME_EXCHANGE -> "GOOD_TILL_TIME_EXCHANGE"
  TimeInForce'GOOD_TILL_TIME_OMS -> "GOOD_TILL_TIME_OMS"
  TimeInForce'FILL_OR_KILL -> "FILL_OR_KILL"
  TimeInForce'IMMEDIATE_OR_CANCEL -> "IMMEDIATE_OR_CANCEL"

-- | parse 'TimeInForce' enum
toTimeInForce :: Text -> P.Either String TimeInForce
toTimeInForce = \case
  "GOOD_TILL_CANCEL" -> P.Right TimeInForce'GOOD_TILL_CANCEL
  "GOOD_TILL_TIME_EXCHANGE" -> P.Right TimeInForce'GOOD_TILL_TIME_EXCHANGE
  "GOOD_TILL_TIME_OMS" -> P.Right TimeInForce'GOOD_TILL_TIME_OMS
  "FILL_OR_KILL" -> P.Right TimeInForce'FILL_OR_KILL
  "IMMEDIATE_OR_CANCEL" -> P.Right TimeInForce'IMMEDIATE_OR_CANCEL
  s -> P.Left $ "toTimeInForce: enum parse failure: " P.++ P.show s



